// Adafruit MCP9808 Library - Version: Latest 
#include <Adafruit_MCP9808.h>

// Adafruit seesaw Library - Version: Lates. For soil sensor
#include <Adafruit_Crickit.h>
#include <Adafruit_NeoTrellis.h>
#include <Adafruit_TFTShield18.h>
#include <Adafruit_miniTFTWing.h>
#include <Adafruit_seesaw.h>
#include <seesaw_motor.h>
#include <seesaw_neopixel.h>
#include <seesaw_servo.h>

// RF24 - Version: Latest
#include <RF24.h>
#include <RF24_config.h>
#include <nRF24L01.h>
#include <printf.h>
#include <SPI.h> //for nrf connection
#include <Wire.h>//i2c library

//Creates a new seesaw object for the soil and temp sensor. 
Adafruit_seesaw soilsense;

//Initialie variables
//const int buttonPin = 2;    // The number of the pushbutton pin
const int tachPin=2;         // Fan tach input pin
int tachPinValue=0;          // Initialize the value to 0
int rpms=0;                   // Fan rpm calculation variable
int fancount=0;               // Fan rpm counter variable
int ledPin = LED_BUILTIN;      // Reference for onboard LED

int ledState = HIGH;         // The current state of the output pin
int buttonState;             // The current reading from the input pin
int lastButtonState = LOW;   // The previous reading from the input pin

// The following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
//Debounce variables
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers

//Fan PWM Variables
const int fanPWM=10; // OCR1B output, which is OC1B. 
int speed=0; // An nrf24l01 testing variable

/*
  The beginning of PlantCam!
*/
// Create the MCP9808 temperature sensor object
Adafruit_MCP9808 tempsensor = Adafruit_MCP9808();

// Create a radio object
RF24 radio(9, 8);

//Begin Setup.
void setup() {
Serial.begin(9600);
Serial.println("NA NA NA NA NA NA NA NA PLANTCAM!");


//Interrupt created for fam RPM reporting. Runs when sei(); is called. 
attachInterrupt(0, rpm, RISING); //(pin, routine to call, rising=trigger when the pin goes from low to high)


//start nrf radio
radio.begin();
radio.setPALevel(RF24_PA_MAX); //set powerlevel max
radio.setChannel(0x76);
const uint64_t pipes[2] = { 0xF0F0F0F0E1LL, 0xF0F0F0F0D2LL };//same pipe address as on pi
radio.openReadingPipe(1, pipes[0]); //start reading pipe
radio.openWritingPipe(pipes[1]);//start writing pipe. Unclear why this is 1 variable instead of 2
radio.setAutoAck(true);
radio.enableDynamicPayloads();
radio.powerUp();
Wire.begin();   

//set up PWM fan
pinMode(fanPWM, OUTPUT);  // fanPWM control pin
pinMode(LED_BUILTIN, OUTPUT); // use the onboard LED to help debugg
pinMode(tachPin, INPUT); // fan tachpin input reading

*/PWM fan notes:
Using Timer1 because it's 16 bits and is the only one that can count up to 25KHz. To do this I need to modify the registers 
directly because its not possible to get this frequency with standard output functions, such as a delay function.

  
  TCCR1A = 0; // Clear Timer1 Counter Control Registers A and B. 
  TCCR1B = 0;
  TCNT1 = 0; // Clear Timer1 Counter Number Register
  
  //Set Timer Counter Control1 Registers A and B to desired operation. 
  TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(WGM10); //Non-inverting output, WGM mode 9. See data sheet for more information
  TCCR1B = _BV(WGM13) | _BV(CS10); //Completes WGM mode 9, CS sets prescaler to 1 which is no clock frequency division. 
  OCR1A = 319; // When using OCR1A as TOP value in a PWM mode, the OCR1A register can not be used for generating a PWM output. 
  /*However, the TOP value will in this case be double buffered allowing the TOP value to be changed in run time. A special feature of 
  output compare A allows it to define the Timer/Counter TOP value (i.e., counter resolution). In addition to the counter 
  resolution, the TOP value defines the period time for waveforms generated by the waveform generator.  
  The top value is defined in the data sheet on page 151 for phase and frequency correct PWM. TOP=f_clock/(2N*f_PWM) which with N=1
  gives a TOP value of 320. It's zero-indexed, so 329.  
  */
  OCR1B = 0; //Output register intialized to 0. 
}

//NEED TO DISABLE/ENABLE INTERRUPTS
 If an interrupt occurs between the two instructions accessing the 16-bit register, and the interrupt code updates the temporary 
 register by accessing the same or any other of the 16-bit timer registers, then the result of the access outside the interrupt 
 will be corrupted. Therefore, when both the main code and the interrupt code update the temporary register, the main code must 
 disable the interrupts during the 16-bit access.

//This is the function that the interupt calls
void rpm (){ 
  fancount++; 
}

void loop() {
  fancount=0;  //reset the rpm count every loop iteration
  radio.startListening() ;        // start listening forever
  char receivedMessage[1];   // set incmng message for 1 byte for a single word. 
  char sentMessage[4]; //handshake variable. Currently unused. 
  String processedMessage="high"; //NOTE: manually set this for TACH signal setup/debugg. Should be "" normally. 
  if (radio.available()) { 
    radio.read(receivedMessage, sizeof(receivedMessage));  // read the message and save. (Save to where/what?)
    
    /*println automatically converts chars to ascii string. This code takes the received char message and turn into a string for 
    if/else checks to execute further code. I chose this to better interface with people using the website. They can then 
    select "high, low, soil" etc.     
    */
    for(int i = 0; i < sizeof(receivedMessage); i++){
     processedMessage+=receivedMessage[i];
      }
      
     //print out the processed message. Testing and verification purposes. 
  Serial.println(processedMessage);
    if (processedMessage=="low"){
      fanOut(1);
    }
    else if(processedMessage=="high"){
      fanOut(2);
    }
    else if (processedMessage=="soil"){
      testThatPlant();
    }
    
  }
//air temp sensor and soil sensor use i2c. Connect in parallel with 4.7K ohm resistor inbetween 
//for pullup.Can use the same pins but then need each device to have different addressing.


//TACH signal functions. Will need to be integrated into the actual functions later. 
if (processedMessage=="high"){
      fanOut(2);
  //enable interripts. This built-in interrupt function uses timer0 so I don't have to worry about it affecting the fans. 
      sei();
 
//Wait 1 second
delay (1000);
 
//Disable interrupts
cli();

rpms=(fancount/2)*60;  //#rpms is equal to the fan count in 1 second/(# of magnets attached to the rotor)*60. #magnets assumed to be 2.
Serial.println(rpms);
    }
}

//Using Adafruit's seesaw library to read the temperature sensor.
void testThatPlant(){  //void functions return nothing. Int functions return a #
  float tempC = soilsense.getTemp();
  uint16_t capread = soilsense.touchRead(0);
  Serial.print("Temperature: "); Serial.print(tempC); Serial.println("*C");
  Serial.print("Capacitive: "); Serial.println(capread);
  delay(4000);//remember that delay uses timer0?
  //return tempC, capread;
}

//fan control functions currently not used. Keeping in case I need them for testing later or decide to change the control mechanism.
void fanOff(int speed){
  fanOut(0);
}

void fanLow(int speed) {
  fanOut(1);
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("here");
}

void fanMed(int speed) {
  fanOut(2);
  digitalWrite(LED_BUILTIN, HIGH);
}

void fanHigh(int speed) {
   digitalWrite(LED_BUILTIN, HIGH);
  fanOut(3);
//calling fanHigh(8, 320)? This doesn't make sense. Either do it in the function
//or pass high, med, low to the fanout function. 
//and if there is only one pin out option, just do it in the function? 
/*
but I want a fan out=med, high, low. Pin is set, change fanout to define the fan speeds. 
can just call fanOut(HIGH), instead of fanSpeed. 
*/
}

//controls the speed of the fan. Plan is to take input from user over the web and enter it here. Will need
  //to find a way to do this.
void fanOut(int speed) { 
  int maxSpeed=640; //the max value of the OCR1A
  //int value; //value=255/
  switch (speed) {
    
    case 1: //ADD INTERRUPTS! ?
      OCR1B=maxSpeed/2;
      //Serial.println(OCR1B);
      break;
      
    case 2:
      OCR1B=maxSpeed-1;
      //Serial.println(OCR1B);
      break;
    
    default:
      //do nothing
      break;
  }

  //next need temp sensing, moisture sensing, connection/communucation with NRFL and somehow with PI.
  //temp sensing in the void loop
  //have to remember that the arduino is a slave to the pi. Also have to remember that right now I'm just getting stuff set up. This
  //can be modified later.

  /* Modification ideas:
    Can the arduino power all the devices at the same time?
    How will I power the fan(s) since they need 12V?
        A great project to design my own 12V power supply!! Definitely should do this.
    Arduino is slave:
    need a start-up function
      Start up all devices and perform system checks
    need a reset function
      shut down and restart all devices and perform system checks. Can loop back to start-up function
    need ways to call check temp, check moisture, monitor fan(s).
      Their own loops? Instead of in loop, should maybe have void moisture check(){}?
  */

}
